// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['backbone', 'underscore', 'collections/tests'], function(Backbone, _, Tests) {
    var TestGroup;

    return TestGroup = Backbone.Model.extend({
      defaults: {
        selected: void 0,
        count: 0,
        empty: false,
        robot: 'None',
        robots: [],
        scenario: 'None',
        scenarios: [],
        navigation: 'None',
        navigations: [],
        enabled: true,
        'mean.duration': 'N/A',
        'mean.distance': 'N/A',
        'mean.rotation': 'N/A',
        'stdDev.duration': 'N/A',
        'stdDev.distance': 'N/A',
        'stdDev.rotation': 'N/A',
        'mean.collisions': 'N/A',
        'std.collisions': 'N/A',
        indexesByCid: {},
        errorsCombined: 0,
        errorsAborted: 0,
        errorsFailed: 0,
        errorsMissed: 0,
        errorsTimedout: 0
      },
      constructor: function(args, options) {
        if (!(args != null)) {
          args = {
            tests: []
          };
        }
        if (args instanceof Tests) {
          args = {
            tests: args
          };
        }
        if (!args.tests) {
          args.tests = [];
        }
        if (args.tests && !(args.tests instanceof Tests)) {
          args.tests = new Tests(args.tests);
        }
        if (args.id == null) {
          args.id = _.uniqueId('testGroup');
        }
        Backbone.Model.call(this, args, options);
        return this;
      },
      initialize: function() {
        this.reset();
        this.set('originalTests', this.get('tests'));
        this.set('tests', this.get('tests').clone());
        this.set('indexesByCid', this.get('tests').getIndexesByCid());
        return this.once('change:filters', function() {
          return this.setupFilters();
        });
      },
      setupFilters: function() {
        var filter, _i, _len, _ref, _results;

        _ref = this.get('filters');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          filter = _ref[_i];
          _results.push(this.listenTo(filter, 'change', this.filterChanged));
        }
        return _results;
      },
      filterChanged: function() {
        this.updateTestsLists();
        return this.refreshAttributes();
      },
      updateTestsLists: function() {
        return this.applyFilters(this.get('filters'));
      },
      filter: function(filter) {
        var clone, filters;

        clone = this.clone();
        filters = clone.get('filters').concat(filter);
        clone.applyFilters(filters);
        return clone;
      },
      applyFilters: function(filters) {
        var newTests;

        newTests = this.get('originalTests').filter(filters);
        return this.set('tests', newTests);
      },
      reset: function() {
        return this.refreshAttributes();
      },
      refreshAttributes: function() {
        var attr, count, _i, _j, _len, _len1, _ref, _ref1;

        _ref = ['robot', 'scenario', 'navigation'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          this.updateUniqAttribute(attr);
        }
        _ref1 = ['duration', 'distance', 'rotation', 'collisions'];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          attr = _ref1[_j];
          this.updateMedianAttribute(attr);
          this.updateStdDevAttribute(attr);
        }
        this.updateErrorCount();
        count = this.get('tests').length;
        this.set('count', count);
        return this.set('empty', count === 0);
      },
      updateUniqAttribute: function(attr) {
        var uniqueValues;

        uniqueValues = [];
        this.get('tests').forEach(function(model) {
          var value;

          value = model.get(attr);
          if ((value != null) && __indexOf.call(uniqueValues, value) < 0) {
            return uniqueValues.push(value);
          }
        });
        this.set(attr + 's', uniqueValues);
        switch (uniqueValues.length) {
          case 0:
            return this.set(attr, 'None');
          case 1:
            return this.set(attr, uniqueValues[0]);
          default:
            return this.set(attr, 'various');
        }
      },
      updateMedianAttribute: function(attr) {
        var num, sum;

        sum = num = 0;
        this.get('tests').forEach(function(model) {
          var value;

          if (model.get('error')) {
            return;
          }
          value = +model.get(attr);
          if (!isNaN(value)) {
            num++;
            return sum += value;
          }
        });
        return this.set('mean.' + attr, num > 0 ? sum / num : 'N/A');
      },
      updateErrorCount: function() {
        var erroneous, errorKeys, errors, errorsCombined, key, _i, _j, _len, _len1, _results;

        errorsCombined = 0;
        errorKeys = ['Aborted', 'Failed', 'Missed', 'Timedout'];
        errors = {};
        for (_i = 0, _len = errorKeys.length; _i < _len; _i++) {
          key = errorKeys[_i];
          errors[key] = 0;
        }
        erroneous = this.get('tests').forEach(function(model) {
          var _j, _len1, _results;

          if (!model.get('error')) {
            return;
          }
          errorsCombined++;
          _results = [];
          for (_j = 0, _len1 = errorKeys.length; _j < _len1; _j++) {
            key = errorKeys[_j];
            if (key.lower() === model.get('error').lower()) {
              _results.push(errors[key]++);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
        _results = [];
        for (_j = 0, _len1 = errorKeys.length; _j < _len1; _j++) {
          key = errorKeys[_j];
          _results.push(this.set('errors' + key, errors[key]));
        }
        return _results;
      },
      updateStdDevAttribute: function(attr) {
        var mean, num, sum,
          _this = this;

        mean = this.get('mean.' + attr);
        sum = num = 0;
        return this.get('tests').map(function(model) {
          var value;

          value = +model.get(attr);
          if (!isNaN(value)) {
            num++;
            sum += Math.pow(value - mean, 2);
          }
          return _this.set('stdDev.' + attr, sum > 0 ? Math.sqrt(sum / num) : 'N/A');
        });
      },
      getDataPointsForKey: function(key) {
        return this.get('tests').map(function(model) {
          if (model.get('error')) {
            return 'error';
          }
          return model.get(key);
        });
      },
      getDetailedDataPointsForKey: function(key) {
        var indexesByCid;

        indexesByCid = this.get('indexesByCid');
        return this.get('tests').map(function(model) {
          return {
            date: model.get('date'),
            error: model.get('error'),
            index: indexesByCid[model.cid],
            y: model.get(key)
          };
        });
      },
      groupBy: function() {
        var tests;

        tests = this.get('tests');
        return tests.groupBy.apply(tests, arguments);
      },
      sortBy: function() {
        var clone, sortedTests, tests;

        clone = this.clone();
        tests = clone.get('tests');
        sortedTests = tests.sortBy.apply(tests, arguments);
        clone.set('tests', sortedTests, {
          silent: true
        });
        return clone;
      }
    });
  });

}).call(this);
